# -*- coding: utf-8 -*-
"""data.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18QHKvKzMZ4QZW_b8iR1HDMLsJytlB4M2
"""

# maya/data.py
import pandas as pd
from rdkit import Chem
from rdkit.Chem.rdmolops import Standardizer, LargestFragmentChooser, Uncharger, Reionizer, TautomerCanonicalizer
from joblib import Parallel, delayed
from typing import Tuple, List
import os
from .config import MayaConfig

def load_dataset(file_path: str, config: MayaConfig) -> pd.DataFrame:
    """Load dataset from various formats and validate."""
    ext = os.path.splitext(file_path)[1].lower().lstrip('.')
    readers = {
        'csv': pd.read_csv, 'xlsx': pd.read_excel, 'tsv': lambda f: pd.read_csv(f, sep='\t'),
        'json': pd.read_json, 'xml': pd.read_xml
    }
    if ext not in readers:
        raise ValueError(f"Unsupported format: {ext}")
    df = readers[ext](file_path)
    required_cols = [config.data['id_col'], config.data['smiles_col']] + config.data['activities']
    missing = set(required_cols) - set(df.columns)
    if missing:
        raise ValueError(f"Missing columns: {missing}")
    if not df[config.data['id_col']].is_unique:
        raise ValueError("Duplicate IDs")
    for col in required_cols:
        if df[col].isnull().any():
            raise ValueError(f"Nulls in {col}")
        if col in config.data['activities'] and not pd.api.types.is_numeric_dtype(df[col]):
            raise TypeError(f"Non-numeric values in {col}")
    return df

def preprocess_smiles(df: pd.DataFrame, smiles_col: str, n_jobs: int) -> Tuple[pd.DataFrame, List]:
    """Preprocess SMILES strings in parallel."""
    std = Standardizer()
    lfc = LargestFragmentChooser()
    uc = Uncharger()
    ri = Reionizer()
    tc = TautomerCanonicalizer()
    allowed = {"H", "B", "C", "N", "O", "F", "Si", "P", "S", "Cl", "Se", "Br", "I"}

    def pretreat(smi):
        try:
            mol = Chem.MolFromSmiles(smi)
            if mol is None:
                return None, "Invalid"
            mol = tc(ri(uc(lfc(std(mol)))))
            if {a.GetSymbol() for a in mol.GetAtoms()}.issubset(allowed):
                return mol, Chem.MolToSmiles(mol)
            return None, "Disallowed"
        except:
            return None, "Error"

    results = Parallel(n_jobs=n_jobs)(delayed(pretreat)(smi) for smi in df[smiles_col])
    mols, canonical = zip(*results)
    df['Canonical_Smiles'] = canonical
    df = df[~df['Canonical_Smiles'].str.startswith(('Invalid', 'Disallowed', 'Error'))]
    df = df.drop_duplicates('Canonical_Smiles').reset_index(drop=True)
    mols = [m for m in mols if m is not None]
    return df, mols
